{
  "version": 3,
  "sources": ["../src/libCrypto.ts", "../src/serverMessages.ts", "../src/intruder.ts"],
<<<<<<< HEAD
  "sourcesContent": ["/* Source: https://gist.github.com/groundrace/b5141062b47dd96a5c21c93839d4b954 */\n\n/* Available functions:\n\n    # Key/nonce generation:\n    generateAssymetricKeysForEncryption(): Promise<CryptoKey[]>\n    generateAssymetricKeysForSignature(): Promise<CryptoKey[]>\n    generateSymetricKey(): Promise<CryptoKey>\n    generateNonce(): string\n\n    # Assymetric key Encryption/Decryption/Signature/Signature verification\n    encryptWithPublicKey(pkey: CryptoKey, message: string): Promise<string>\n    decryptWithPrivateKey(skey: CryptoKey, message: string): Promise<string>\n    signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string>\n    verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean>\n\n    # Symmetric key Encryption/Decryption\n    encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]>\n    decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string>\n\n    # Importing keys from string\n    stringToPublicKeyForEncryption(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForEncryption(skeyInBase64: string): Promise<CryptoKey>\n    stringToPublicKeyForSignature(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForSignature(skeyInBase64: string): Promise<CryptoKey>\n    stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey>\n\n    # Exporting keys to string\n    publicKeyToString(key: CryptoKey): Promise<string>\n    privateKeyToString(key: CryptoKey): Promise<string>\n    symmetricKeyToString(key: CryptoKey): Promise<string>\n\n    # Hashing\n    hash(text: string): Promise<string>\n*/\n\n// import { subtle } from 'crypto'\n// LibCrypto---------------------------------------------------------------------------\n\n/*\nImports the given public key (for encryption) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForEncryption(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"encrypt\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given public key (for signature verification) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForSignature(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"verify\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for decryption)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForEncryption(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for signature)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForSignature(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\n\nexport async function publicKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"spki\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function privateKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Generates a pair of public and private RSA keys for encryption/decryption */\nexport async function generateAssymetricKeysForEncryption(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-OAEP\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a pair of public and private RSA keys for signing/verifying */\nexport async function generateAssymetricKeysForSignature(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"sign\", \"verify\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a random nonce */\nexport function generateNonce(): string {\n    const nonceArray = new Uint32Array(1)\n    self.crypto.getRandomValues(nonceArray)\n    return nonceArray[0].toString()\n}\n\n/* Encrypts a message with a public key */\nexport async function encryptWithPublicKey(publicKey: CryptoKey, message: string): Promise<string> {\n    console.log(\"Encrypt with \" + publicKey + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"RSA-OAEP\" },\n            publicKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(cypheredMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Public key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/* Sign a message with a private key */\nexport async function signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    console.log(\"Sign with \" + privateKey + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const signedMessageAB: ArrayBuffer = await window.crypto.subtle.sign(\n            \"RSASSA-PKCS1-v1_5\",\n            privateKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(signedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Signature failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Private key or message to sign is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Decrypts a message with a private key */\nexport async function decryptWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"RSA-OAEP\" },\n                privateKey,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Private key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Verification of a signature on a message with a public key */\nexport async function verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean> {\n    try {\n        const signedToArrayBuffer = base64StringToArrayBuffer(signedMessage)\n        const messageInClearToArrayBuffer = textToArrayBuffer(messageInClear)\n        const verified: boolean = await\n            window.crypto.subtle.verify(\n                \"RSASSA-PKCS1-v1_5\",\n                publicKey,\n                signedToArrayBuffer,\n                messageInClearToArrayBuffer)\n        return verified\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for signature verification\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Public key or signed message to verify is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Generates a symmetric AES-GCM key */\nexport async function generateSymetricKey(): Promise<CryptoKey> {\n    const key: CryptoKey = await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return key\n}\n\n/* a symmetric AES key into a string */\nexport async function symmetricKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"raw\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Imports the given key (in string) as a valid AES key */\nexport async function stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"raw\",\n            keyArrayBuffer,\n            \"AES-GCM\",\n            true,\n            [\"encrypt\", \"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n// When cyphering a message with a key in AES, we obtain a cyphered message and an \"initialisation vector\".\n// In this implementation, the output is a two elements array t such that t[0] is the cyphered message\n// and t[1] is the initialisation vector. To simplify, the initialisation vector is represented by a string.\n// The initialisation vectore is used for protecting the encryption, i.e, 2 encryptions of the same message \n// with the same key will never result into the same encrypted message.\n// \n// Note that for decyphering, the **same** initialisation vector will be needed.\n// This vector can safely be transferred in clear with the encrypted message.\n\nexport async function encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]> {\n    console.log(\"Encrypt with \" + key + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const ivText = arrayBufferToBase64String(iv)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv },\n            key,\n            messageToArrayBuffer\n        )\n        return [arrayBufferToBase64String(cypheredMessageAB), ivText]\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Symmetric key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n// For decyphering, we need the key, the cyphered message and the initialization vector. See above the \n// comments for the encryptWithSymmetricKey function\nexport async function decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string> {\n    const decodedInitVector: ArrayBuffer = base64StringToArrayBuffer(initVector)\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"AES-GCM\", iv: decodedInitVector },\n                key,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Symmetric key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n// SHA-256 Hash from a text\nexport async function hash(text: string): Promise<string> {\n    const text2arrayBuf = textToArrayBuffer(text)\n    const hashedArray = await window.crypto.subtle.digest(\"SHA-256\", text2arrayBuf)\n    return arrayBufferToBase64String(hashedArray)\n}\n\nclass KeyStringCorrupted extends Error { }\n\n// ArrayBuffer to a Base64 string\nfunction arrayBufferToBase64String(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var byteString = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        byteString += String.fromCharCode(byteArray[i])\n    }\n    return btoa(byteString)\n}\n\n// Base64 string to an arrayBuffer\nfunction base64StringToArrayBuffer(b64str: string): ArrayBuffer {\n    try {\n        var byteStr = atob(b64str)\n        var bytes = new Uint8Array(byteStr.length)\n        for (var i = 0; i < byteStr.length; i++) {\n            bytes[i] = byteStr.charCodeAt(i)\n        }\n        return bytes.buffer\n    } catch (e) {\n        console.log(`String starting by '${b64str.substring(0, 10)}' cannot be converted to a valid key or message`)\n        throw new KeyStringCorrupted\n    }\n}\n\n// String to array buffer\nfunction textToArrayBuffer(str: string): ArrayBuffer {\n    var buf = encodeURIComponent(str) // 2 bytes for each char\n    var bufView = new Uint8Array(buf.length)\n    for (var i = 0; i < buf.length; i++) {\n        bufView[i] = buf.charCodeAt(i)\n    }\n    return bufView\n}\n\n// Array buffers to string\nfunction arrayBufferToText(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var str = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return decodeURIComponent(str)\n}\n\n", "// All message types between the application and the server\n// Message for user name\nexport class CasUserName {\n    constructor(public username: string) { }\n}\n\n\n// Message for requiring history\nexport class HistoryRequest {\n    constructor(public agentName: string, public index: number) { }\n}\n\n// Result of history request\nexport class HistoryAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public index: number,\n        public allMessages: ExtMessage[]) { }\n}\n\n// Filtering of messages\nexport class FilterRequest {\n    constructor(public from: string, public to: string, public indexmin: string) { }\n}\n\nexport class FilteredMessage {\n    constructor(public message: ExtMessage,\n        public index: number,\n        public deleted: boolean,\n        public deleter: string) { }\n}\n\n// Result of filtering request\nexport class FilteringAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public allMessages: FilteredMessage[]) { }\n}\n\n// Sending a message Result format\nexport class SendResult {\n    constructor(public success: boolean, public errorMessage: string) { }\n}\n\n// Sending messages\n// The message format\nexport class ExtMessage {\n    constructor(public sender: string, public receiver: string, public content: string) { }\n}\n\nexport class DeletingRequest {\n    constructor(\n        public indexToDelete: string) { }\n}\n\nexport class DeletingAnswer {\n    constructor(public success: boolean,\n        message: string) { }\n}\n\n// Requesting keys\nexport class KeyRequest {\n    constructor(public ownerOfTheKey: string, public publicKey: boolean, public encryption: boolean) { }\n}\n\nexport class KeyResult {\n    constructor(public success: boolean, public key: string, public errorMessage: string) { }\n}", "/* tsc --inlineSourceMap true -outFile JS/intruder.js src/libCrypto.ts src/intruder.ts --target es2015 */\n\nimport {\n    generateNonce,\n    stringToPrivateKeyForEncryption, stringToPublicKeyForEncryption,\n    publicKeyToString, privateKeyToString, stringToPrivateKeyForSignature,\n    stringToPublicKeyForSignature,\n} from './libCrypto'\n\nimport {\n    DeletingRequest, DeletingAnswer, FilterRequest, FilteringAnswer, KeyRequest,\n    KeyResult, CasUserName, ExtMessage, SendResult\n} from './serverMessages'\n\nconst filterButton = document.getElementById(\"filter-button\") as HTMLButtonElement\nconst sendButton = document.getElementById(\"send-button\") as HTMLButtonElement\nconst deleteButton = document.getElementById(\"delete-button\") as HTMLButtonElement\nconst getPublicKeyButton = document.getElementById(\"get-public-key-button\") as HTMLButtonElement\nconst getPrivateKeyButton = document.getElementById(\"get-private-key-button\") as HTMLButtonElement\n\nconst generateNonceButton = document.getElementById(\"generate-nonce-button\") as HTMLButtonElement\n\nconst public_key_owner = document.getElementById(\"public-key-owner\") as HTMLInputElement\nconst private_key_owner = document.getElementById(\"private-key-owner\") as HTMLInputElement\n\nconst publicKeyElementEnc = document.getElementById(\"public-key-enc\") as HTMLLabelElement\nconst privateKeyElementEnc = document.getElementById(\"private-key-enc\") as HTMLLabelElement\nconst publicKeyElementSign = document.getElementById(\"public-key-sign\") as HTMLLabelElement\nconst privateKeyElementSign = document.getElementById(\"private-key-sign\") as HTMLLabelElement\n\nconst nonceTextElement = document.getElementById(\"nonce\") as HTMLLabelElement\n\nconst from = document.getElementById(\"from\") as HTMLInputElement\nconst to = document.getElementById(\"to\") as HTMLInputElement\nconst indexminElt = document.getElementById(\"indexmin\") as HTMLInputElement\nconst filtered_messages = document.getElementById(\"filtered-messages\") as HTMLLabelElement\n\nconst sendfrom = document.getElementById(\"sendfrom\") as HTMLInputElement\nconst sendto = document.getElementById(\"sendto\") as HTMLInputElement\nconst sendcontent = document.getElementById(\"sendcontent\") as HTMLInputElement\nconst deleteIndex = document.getElementById(\"deleteindex\") as HTMLInputElement\n\nasync function fetchCasName(): Promise<string> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const namerequest = await fetch(\"/getuser?\" + urlParams, {\n        method: \"GET\",\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!namerequest.ok) {\n        throw new Error(`Error! status: ${namerequest.status}`);\n    }\n    const nameResult = (await namerequest.json()) as CasUserName;\n    return nameResult.username\n}\n\n// We set the default CAS name for the public key fields\nasync function setCasName() {\n    public_key_owner.value = await fetchCasName()\n    private_key_owner.value = await fetchCasName()\n}\nsetCasName()\n\n/* Name of the owner/developper of the application, i.e, the name of the folder \n   where the web page of the application is stored. E.g, for teachers' application\n   this name is \"ens\" */\n\nfunction getOwnerName(): string {\n    const path = window.location.pathname\n    const name = path.split(\"/\", 2)[1]\n    return name\n}\n\nlet ownerName = getOwnerName()\n\nfunction clearingMessages() {\n    filtered_messages.textContent = \"\"\n}\n\nfunction stringToHTML(str: string): HTMLDivElement {\n    var div_elt = document.createElement('div')\n    div_elt.innerHTML = str\n    return div_elt\n}\n\nfunction addingFilteredMessage(message: string) {\n    filtered_messages.append(stringToHTML('<p></p><p></p>' + message))\n}\n\ngenerateNonceButton.onclick = function () {\n    const nonce = generateNonce()\n    nonceTextElement.textContent = nonce\n}\n\nasync function fetchKey(user: string, publicKey: boolean, encryption: boolean): Promise<CryptoKey> {\n    // Getting the public/private key of user. \n    // For public key the boolean 'publicKey' is true.\n    // For private key the boolean 'publicKey' is false.\n    // If the key is used for encryption/decryption then the boolean 'encryption' is true.\n    // If the key is used for signature/signature verification then the boolean is false.\n    const keyRequestMessage =\n        new KeyRequest(user, publicKey, encryption)\n    // For CAS authentication we need to add the authentication ticket\n    // It is contained in urlParams\n    const urlParams = new URLSearchParams(window.location.search);\n    // For getting a key we do not need the ownerName param\n    // Because keys are independant of the applications\n    const keyrequest = await fetch(\"/getKey?\" + urlParams, {\n        method: \"POST\",\n        body: JSON.stringify(keyRequestMessage),\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!keyrequest.ok) {\n        throw new Error(`Error! status: ${keyrequest.status}`);\n    }\n    const keyResult = (await keyrequest.json()) as KeyResult;\n    if (!keyResult.success) alert(keyResult.errorMessage)\n    else {\n        if (publicKey) return await stringToPublicKeyForEncryption(keyResult.key)\n        else return await stringToPrivateKeyForEncryption(keyResult.key)\n    }\n}\n\ngetPublicKeyButton.onclick = async function () {\n    const public_key_owner_name = public_key_owner.value\n    const publicKeyEnc = await fetchKey(public_key_owner_name, true, true)\n    const publicKeySign = await fetchKey(public_key_owner_name, true, false)\n    publicKeyElementEnc.textContent = await publicKeyToString(publicKeyEnc)\n    publicKeyElementSign.textContent = await publicKeyToString(publicKeySign)\n}\n\ngetPrivateKeyButton.onclick = async function () {\n    const private_key_owner_name = private_key_owner.value\n    const privateKeyEnc = await fetchKey(private_key_owner_name, false, true)\n    const privateKeySign = await fetchKey(private_key_owner_name, false, false)\n    privateKeyElementEnc.textContent = await privateKeyToString(privateKeyEnc)\n    privateKeyElementSign.textContent = await privateKeyToString(privateKeySign)\n}\n\ndeleteButton.onclick = async function () {\n    let indexToDelete = deleteIndex.value\n    const urlParams = new URLSearchParams(window.location.search);\n    try {\n        let deleteRequest =\n            new DeletingRequest(indexToDelete)\n        const request = await fetch(\"/deleting/\" + ownerName + \"?\" + urlParams, {\n            method: \"POST\",\n            body: JSON.stringify(deleteRequest),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as DeletingAnswer\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            alert(error.message)\n            //console.log('error message: ', error.message);\n            return new DeletingAnswer(false, error.message)\n        } else {\n            console.log('unexpected error: ', error);\n            return new DeletingAnswer(false, 'An unexpected error occurred')\n        }\n    }\n\n}\n\nasync function sendMessage(agentName: string, receiverName: string, messageContent: string): Promise<SendResult> {\n    try {\n        let messageToSend = new ExtMessage(agentName, receiverName, messageContent)\n        const urlParams = new URLSearchParams(window.location.search);\n        const request = await fetch(\"/intruderSendingMessage/\" + ownerName + \"?\" + urlParams, {\n            method: \"POST\",\n            body: JSON.stringify(messageToSend),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as SendResult\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log(error.message)\n            return new SendResult(false, error.message)\n        } else {\n            console.log(error)\n            return new SendResult(false, 'An unexpected error occurred')\n        }\n    }\n}\n\n// the intruder sends a message in place of any user\nsendButton.onclick = async function () {\n    let agentName = sendfrom.value\n    let receiverName = sendto.value\n    let content = sendcontent.value\n    try {\n        const sendResult = await sendMessage(agentName, receiverName, content)\n        if (!sendResult.success) alert(sendResult.errorMessage)\n        else {\n            console.log(\"Successfully sent the message!\")\n        }\n    } catch (e) {\n        if (e instanceof Error) {\n            console.log(e.message)\n        } else {\n            console.log(e)\n        }\n    }\n}\n\nfilterButton.onclick = async function () {\n    try {\n        const fromText = from.value\n        const toText = to.value\n        const indexmin = indexminElt.value\n        const filterRequest =\n            new FilterRequest(fromText, toText, indexmin)\n        // For CAS authentication we need to add the authentication ticket\n        // It is contained in urlParams\n        const urlParams = new URLSearchParams(window.location.search);\n        const request = await fetch(\"/filtering/\" + ownerName + \"?\" + urlParams, {\n            method: \"POST\",\n            body: JSON.stringify(filterRequest),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        const result = (await request.json()) as FilteringAnswer\n        if (!result.success) { alert(result.failureMessage) }\n        else {\n            clearingMessages()\n            for (var filt_message of result.allMessages) {\n                if (filt_message.deleted) {\n                    addingFilteredMessage(`Index: ${filt_message.index} Deleted by: ${filt_message.deleter} <strike> From: ${filt_message.message.sender} To: ${filt_message.message.receiver} Content: ${filt_message.message.content} </strike>`)\n                } else {\n                    addingFilteredMessage(`Index: ${filt_message.index} From: ${filt_message.message.sender} To: ${filt_message.message.receiver} Content: ${filt_message.message.content}`)\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return error.message;\n        } else {\n            console.log('unexpected error: ', error);\n            return 'An unexpected error occurred';\n        }\n    }\n}\n\n"],
  "mappings": ";;AA2CA,iBAAsB,+BAA+B,YAAwC;AACzF,QAAI;AACA,YAAM,iBAA8B,0BAA0B,UAAU;AACxE,YAAM,MAAiB,MAAM,OAAO,OAAO,OAAO;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,MAAM;AAAA,QACV;AAAA,QACA;AAAA,QACA,CAAC,SAAS;AAAA,MACd;AACA,aAAO;AAAA,IACX,SAAS,GAAG;AACR,UAAI,aAAa,cAAc;AAAE,gBAAQ,IAAI,2DAA2D;AAAA,MAAE,WACjG,aAAa,oBAAoB;AAAE,gBAAQ,IAAI,2DAA2D;AAAA,MAAE,OAChH;AAAE,gBAAQ,IAAI,CAAC;AAAA,MAAE;AACtB,YAAM;AAAA,IACV;AAAA,EACJ;AAgCA,iBAAsB,gCAAgC,YAAwC;AAC1F,QAAI;AACA,YAAM,iBAA8B,0BAA0B,UAAU;AACxE,YAAM,MAAiB,MAAM,OAAO,OAAO,OAAO;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,UACI,MAAM;AAAA,UACN,MAAM;AAAA,QACV;AAAA,QACA;AAAA,QACA,CAAC,SAAS;AAAA,MAAC;AACf,aAAO;AAAA,IACX,SAAS,GAAG;AACR,UAAI,aAAa,cAAc;AAAE,gBAAQ,IAAI,4DAA4D;AAAA,MAAE,WAClG,aAAa,oBAAoB;AAAE,gBAAQ,IAAI,4DAA4D;AAAA,MAAE,OACjH;AAAE,gBAAQ,IAAI,CAAC;AAAA,MAAE;AACtB,YAAM;AAAA,IACV;AAAA,EACJ;AA+BA,iBAAsB,kBAAkB,KAAiC;AACrE,UAAM,cAA2B,MAAM,OAAO,OAAO,OAAO,UAAU,QAAQ,GAAG;AACjF,WAAO,0BAA0B,WAAW;AAAA,EAChD;AAMA,iBAAsB,mBAAmB,KAAiC;AACtE,UAAM,cAA2B,MAAM,OAAO,OAAO,OAAO,UAAU,SAAS,GAAG;AAClF,WAAO,0BAA0B,WAAW;AAAA,EAChD;AAiCO,WAAS,gBAAwB;AACpC,UAAM,aAAa,IAAI,YAAY,CAAC;AACpC,SAAK,OAAO,gBAAgB,UAAU;AACtC,WAAO,WAAW,CAAC,EAAE,SAAS;AAAA,EAClC;AAyLA,MAAM,qBAAN,cAAiC,MAAM;AAAA,EAAE;AAGzC,WAAS,0BAA0B,aAAkC;AACjE,QAAI,YAAY,IAAI,WAAW,WAAW;AAC1C,QAAI,aAAa;AACjB,aAAS,IAAI,GAAG,IAAI,UAAU,YAAY,KAAK;AAC3C,oBAAc,OAAO,aAAa,UAAU,CAAC,CAAC;AAAA,IAClD;AACA,WAAO,KAAK,UAAU;AAAA,EAC1B;AAGA,WAAS,0BAA0B,QAA6B;AAC5D,QAAI;AACA,UAAI,UAAU,KAAK,MAAM;AACzB,UAAI,QAAQ,IAAI,WAAW,QAAQ,MAAM;AACzC,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,cAAM,CAAC,IAAI,QAAQ,WAAW,CAAC;AAAA,MACnC;AACA,aAAO,MAAM;AAAA,IACjB,SAAS,GAAG;AACR,cAAQ,IAAI,uBAAuB,OAAO,UAAU,GAAG,EAAE,CAAC,iDAAiD;AAC3G,YAAM,IAAI;AAAA,IACd;AAAA,EACJ;;;AC/XO,MAAM,gBAAN,MAAoB;AAAA,IACvB,YAAmBA,OAAqBC,KAAmB,UAAkB;AAA1D,kBAAAD;AAAqB,gBAAAC;AAAmB;AAAA,IAAoB;AAAA,EACnF;AAiBO,MAAM,aAAN,MAAiB;AAAA,IACpB,YAAmB,SAAyB,cAAsB;AAA/C;AAAyB;AAAA,IAAwB;AAAA,EACxE;AAIO,MAAM,aAAN,MAAiB;AAAA,IACpB,YAAmB,QAAuB,UAAyB,SAAiB;AAAjE;AAAuB;AAAyB;AAAA,IAAmB;AAAA,EAC1F;AAEO,MAAM,kBAAN,MAAsB;AAAA,IACzB,YACW,eAAuB;AAAvB;AAAA,IAAyB;AAAA,EACxC;AAEO,MAAM,iBAAN,MAAqB;AAAA,IACxB,YAAmB,SACf,SAAiB;AADF;AAAA,IACI;AAAA,EAC3B;AAGO,MAAM,aAAN,MAAiB;AAAA,IACpB,YAAmB,eAA8B,WAA2B,YAAqB;AAA9E;AAA8B;AAA2B;AAAA,IAAuB;AAAA,EACvG;;;ACjDA,MAAM,eAAe,SAAS,eAAe,eAAe;AAC5D,MAAM,aAAa,SAAS,eAAe,aAAa;AACxD,MAAM,eAAe,SAAS,eAAe,eAAe;AAC5D,MAAM,qBAAqB,SAAS,eAAe,uBAAuB;AAC1E,MAAM,sBAAsB,SAAS,eAAe,wBAAwB;AAE5E,MAAM,sBAAsB,SAAS,eAAe,uBAAuB;AAE3E,MAAM,mBAAmB,SAAS,eAAe,kBAAkB;AACnE,MAAM,oBAAoB,SAAS,eAAe,mBAAmB;AAErE,MAAM,sBAAsB,SAAS,eAAe,gBAAgB;AACpE,MAAM,uBAAuB,SAAS,eAAe,iBAAiB;AACtE,MAAM,uBAAuB,SAAS,eAAe,iBAAiB;AACtE,MAAM,wBAAwB,SAAS,eAAe,kBAAkB;AAExE,MAAM,mBAAmB,SAAS,eAAe,OAAO;AAExD,MAAM,OAAO,SAAS,eAAe,MAAM;AAC3C,MAAM,KAAK,SAAS,eAAe,IAAI;AACvC,MAAM,cAAc,SAAS,eAAe,UAAU;AACtD,MAAM,oBAAoB,SAAS,eAAe,mBAAmB;AAErE,MAAM,WAAW,SAAS,eAAe,UAAU;AACnD,MAAM,SAAS,SAAS,eAAe,QAAQ;AAC/C,MAAM,cAAc,SAAS,eAAe,aAAa;AACzD,MAAM,cAAc,SAAS,eAAe,aAAa;AAEzD,iBAAe,eAAgC;AAC3C,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,UAAM,cAAc,MAAM,MAAM,cAAc,WAAW;AAAA,MACrD,QAAQ;AAAA,MACR,SAAS;AAAA,QACL,gBAAgB;AAAA,MACpB;AAAA,IACJ,CAAC;AACD,QAAI,CAAC,YAAY,IAAI;AACjB,YAAM,IAAI,MAAM,kBAAkB,YAAY,MAAM,EAAE;AAAA,IAC1D;AACA,UAAM,aAAc,MAAM,YAAY,KAAK;AAC3C,WAAO,WAAW;AAAA,EACtB;AAGA,iBAAe,aAAa;AACxB,qBAAiB,QAAQ,MAAM,aAAa;AAC5C,sBAAkB,QAAQ,MAAM,aAAa;AAAA,EACjD;AACA,aAAW;AAMX,WAAS,eAAuB;AAC5B,UAAM,OAAO,OAAO,SAAS;AAC7B,UAAM,OAAO,KAAK,MAAM,KAAK,CAAC,EAAE,CAAC;AACjC,WAAO;AAAA,EACX;AAEA,MAAI,YAAY,aAAa;AAE7B,WAAS,mBAAmB;AACxB,sBAAkB,cAAc;AAAA,EACpC;AAEA,WAAS,aAAa,KAA6B;AAC/C,QAAI,UAAU,SAAS,cAAc,KAAK;AAC1C,YAAQ,YAAY;AACpB,WAAO;AAAA,EACX;AAEA,WAAS,sBAAsB,SAAiB;AAC5C,sBAAkB,OAAO,aAAa,mBAAmB,OAAO,CAAC;AAAA,EACrE;AAEA,sBAAoB,UAAU,WAAY;AACtC,UAAM,QAAQ,cAAc;AAC5B,qBAAiB,cAAc;AAAA,EACnC;AAEA,iBAAe,SAAS,MAAc,WAAoB,YAAyC;AAM/F,UAAM,oBACF,IAAI,WAAW,MAAM,WAAW,UAAU;AAG9C,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAG5D,UAAM,aAAa,MAAM,MAAM,aAAa,WAAW;AAAA,MACnD,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,iBAAiB;AAAA,MACtC,SAAS;AAAA,QACL,gBAAgB;AAAA,MACpB;AAAA,IACJ,CAAC;AACD,QAAI,CAAC,WAAW,IAAI;AAChB,YAAM,IAAI,MAAM,kBAAkB,WAAW,MAAM,EAAE;AAAA,IACzD;AACA,UAAM,YAAa,MAAM,WAAW,KAAK;AACzC,QAAI,CAAC,UAAU,QAAS,OAAM,UAAU,YAAY;AAAA,SAC/C;AACD,UAAI,UAAW,QAAO,MAAM,+BAA+B,UAAU,GAAG;AAAA,UACnE,QAAO,MAAM,gCAAgC,UAAU,GAAG;AAAA,IACnE;AAAA,EACJ;AAEA,qBAAmB,UAAU,iBAAkB;AAC3C,UAAM,wBAAwB,iBAAiB;AAC/C,UAAM,eAAe,MAAM,SAAS,uBAAuB,MAAM,IAAI;AACrE,UAAM,gBAAgB,MAAM,SAAS,uBAAuB,MAAM,KAAK;AACvE,wBAAoB,cAAc,MAAM,kBAAkB,YAAY;AACtE,yBAAqB,cAAc,MAAM,kBAAkB,aAAa;AAAA,EAC5E;AAEA,sBAAoB,UAAU,iBAAkB;AAC5C,UAAM,yBAAyB,kBAAkB;AACjD,UAAM,gBAAgB,MAAM,SAAS,wBAAwB,OAAO,IAAI;AACxE,UAAM,iBAAiB,MAAM,SAAS,wBAAwB,OAAO,KAAK;AAC1E,yBAAqB,cAAc,MAAM,mBAAmB,aAAa;AACzE,0BAAsB,cAAc,MAAM,mBAAmB,cAAc;AAAA,EAC/E;AAEA,eAAa,UAAU,iBAAkB;AACrC,QAAI,gBAAgB,YAAY;AAChC,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,QAAI;AACA,UAAI,gBACA,IAAI,gBAAgB,aAAa;AACrC,YAAM,UAAU,MAAM,MAAM,eAAe,YAAY,MAAM,WAAW;AAAA,QACpE,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU,aAAa;AAAA,QAClC,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,QAAQ,IAAI;AACb,cAAM,IAAI,MAAM,kBAAkB,QAAQ,MAAM,EAAE;AAAA,MACtD;AAEA,aAAQ,MAAM,QAAQ,KAAK;AAAA,IAC/B,SACO,OAAO;AACV,UAAI,iBAAiB,OAAO;AACxB,cAAM,MAAM,OAAO;AAEnB,eAAO,IAAI,eAAe,OAAO,MAAM,OAAO;AAAA,MAClD,OAAO;AACH,gBAAQ,IAAI,sBAAsB,KAAK;AACvC,eAAO,IAAI,eAAe,OAAO,8BAA8B;AAAA,MACnE;AAAA,IACJ;AAAA,EAEJ;AAEA,iBAAe,YAAY,WAAmB,cAAsB,gBAA6C;AAC7G,QAAI;AACA,UAAI,gBAAgB,IAAI,WAAW,WAAW,cAAc,cAAc;AAC1E,YAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,YAAM,UAAU,MAAM,MAAM,6BAA6B,YAAY,MAAM,WAAW;AAAA,QAClF,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU,aAAa;AAAA,QAClC,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,QAAQ,IAAI;AACb,cAAM,IAAI,MAAM,kBAAkB,QAAQ,MAAM,EAAE;AAAA,MACtD;AAEA,aAAQ,MAAM,QAAQ,KAAK;AAAA,IAC/B,SACO,OAAO;AACV,UAAI,iBAAiB,OAAO;AACxB,gBAAQ,IAAI,MAAM,OAAO;AACzB,eAAO,IAAI,WAAW,OAAO,MAAM,OAAO;AAAA,MAC9C,OAAO;AACH,gBAAQ,IAAI,KAAK;AACjB,eAAO,IAAI,WAAW,OAAO,8BAA8B;AAAA,MAC/D;AAAA,IACJ;AAAA,EACJ;AAGA,aAAW,UAAU,iBAAkB;AACnC,QAAI,YAAY,SAAS;AACzB,QAAI,eAAe,OAAO;AAC1B,QAAI,UAAU,YAAY;AAC1B,QAAI;AACA,YAAM,aAAa,MAAM,YAAY,WAAW,cAAc,OAAO;AACrE,UAAI,CAAC,WAAW,QAAS,OAAM,WAAW,YAAY;AAAA,WACjD;AACD,gBAAQ,IAAI,gCAAgC;AAAA,MAChD;AAAA,IACJ,SAAS,GAAG;AACR,UAAI,aAAa,OAAO;AACpB,gBAAQ,IAAI,EAAE,OAAO;AAAA,MACzB,OAAO;AACH,gBAAQ,IAAI,CAAC;AAAA,MACjB;AAAA,IACJ;AAAA,EACJ;AAEA,eAAa,UAAU,iBAAkB;AACrC,QAAI;AACA,YAAM,WAAW,KAAK;AACtB,YAAM,SAAS,GAAG;AAClB,YAAM,WAAW,YAAY;AAC7B,YAAM,gBACF,IAAI,cAAc,UAAU,QAAQ,QAAQ;AAGhD,YAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,YAAM,UAAU,MAAM,MAAM,gBAAgB,YAAY,MAAM,WAAW;AAAA,QACrE,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU,aAAa;AAAA,QAClC,SAAS;AAAA,UACL,gBAAgB;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,UAAI,CAAC,QAAQ,IAAI;AACb,cAAM,IAAI,MAAM,kBAAkB,QAAQ,MAAM,EAAE;AAAA,MACtD;AACA,YAAM,SAAU,MAAM,QAAQ,KAAK;AACnC,UAAI,CAAC,OAAO,SAAS;AAAE,cAAM,OAAO,cAAc;AAAA,MAAE,OAC/C;AACD,yBAAiB;AACjB,iBAAS,gBAAgB,OAAO,aAAa;AACzC,cAAI,aAAa,SAAS;AACtB,kCAAsB,UAAU,aAAa,KAAK,gBAAgB,aAAa,OAAO,mBAAmB,aAAa,QAAQ,MAAM,QAAQ,aAAa,QAAQ,QAAQ,aAAa,aAAa,QAAQ,OAAO,YAAY;AAAA,UAClO,OAAO;AACH,kCAAsB,UAAU,aAAa,KAAK,UAAU,aAAa,QAAQ,MAAM,QAAQ,aAAa,QAAQ,QAAQ,aAAa,aAAa,QAAQ,OAAO,EAAE;AAAA,UAC3K;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SACO,OAAO;AACV,UAAI,iBAAiB,OAAO;AACxB,gBAAQ,IAAI,mBAAmB,MAAM,OAAO;AAC5C,eAAO,MAAM;AAAA,MACjB,OAAO;AACH,gBAAQ,IAAI,sBAAsB,KAAK;AACvC,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;",
=======
  "sourcesContent": ["/* Source: https://gist.github.com/groundrace/b5141062b47dd96a5c21c93839d4b954 */\n\n/* Available functions:\n\n    # Key/nonce generation:\n    generateAssymetricKeysForEncryption(): Promise<CryptoKey[]>\n    generateAssymetricKeysForSignature(): Promise<CryptoKey[]>\n    generateSymetricKey(): Promise<CryptoKey>\n    generateNonce(): string\n\n    # Assymetric key Encryption/Decryption/Signature/Signature verification\n    encryptWithPublicKey(pkey: CryptoKey, message: string): Promise<string>\n    decryptWithPrivateKey(skey: CryptoKey, message: string): Promise<string>\n    signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string>\n    verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean>\n\n    # Symmetric key Encryption/Decryption\n    encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]>\n    decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string>\n\n    # Importing keys from string\n    stringToPublicKeyForEncryption(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForEncryption(skeyInBase64: string): Promise<CryptoKey>\n    stringToPublicKeyForSignature(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForSignature(skeyInBase64: string): Promise<CryptoKey>\n    stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey>\n\n    # Exporting keys to string\n    publicKeyToString(key: CryptoKey): Promise<string>\n    privateKeyToString(key: CryptoKey): Promise<string>\n    symmetricKeyToString(key: CryptoKey): Promise<string>\n\n    # Hashing\n    hash(text: string): Promise<string>\n*/\n\n// import { subtle } from 'crypto'\n// LibCrypto---------------------------------------------------------------------------\n\n/*\nImports the given public key (for encryption) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForEncryption(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"encrypt\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given public key (for signature verification) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForSignature(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"verify\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for decryption)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForEncryption(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for signature)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForSignature(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\n\nexport async function publicKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"spki\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function privateKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Generates a pair of public and private RSA keys for encryption/decryption */\nexport async function generateAssymetricKeysForEncryption(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-OAEP\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a pair of public and private RSA keys for signing/verifying */\nexport async function generateAssymetricKeysForSignature(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"sign\", \"verify\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a random nonce */\nexport function generateNonce(): string {\n    const nonceArray = new Uint32Array(1)\n    self.crypto.getRandomValues(nonceArray)\n    return nonceArray[0].toString()\n}\n\n/* Encrypts a message with a public key */\nexport async function encryptWithPublicKey(publicKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"RSA-OAEP\" },\n            publicKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(cypheredMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Public key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Sign a message with a private key */\nexport async function signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const signedMessageAB: ArrayBuffer = await window.crypto.subtle.sign(\n            \"RSASSA-PKCS1-v1_5\",\n            privateKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(signedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Signature failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Private key or message to sign is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Decrypts a message with a private key */\nexport async function decryptWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"RSA-OAEP\" },\n                privateKey,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Private key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Verification of a signature on a message with a public key */\nexport async function verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean> {\n    try {\n        const signedToArrayBuffer = base64StringToArrayBuffer(signedMessage)\n        const messageInClearToArrayBuffer = textToArrayBuffer(messageInClear)\n        const verified: boolean = await\n            window.crypto.subtle.verify(\n                \"RSASSA-PKCS1-v1_5\",\n                publicKey,\n                signedToArrayBuffer,\n                messageInClearToArrayBuffer)\n        return verified\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for signature verification\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Public key or signed message to verify is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Generates a symmetric AES-GCM key */\nexport async function generateSymetricKey(): Promise<CryptoKey> {\n    const key: CryptoKey = await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return key\n}\n\n/* a symmetric AES key into a string */\nexport async function symmetricKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"raw\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Imports the given key (in string) as a valid AES key */\nexport async function stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"raw\",\n            keyArrayBuffer,\n            \"AES-GCM\",\n            true,\n            [\"encrypt\", \"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n// When cyphering a message with a key in AES, we obtain a cyphered message and an \"initialisation vector\".\n// In this implementation, the output is a two elements array t such that t[0] is the cyphered message\n// and t[1] is the initialisation vector. To simplify, the initialisation vector is represented by a string.\n// The initialisation vectore is used for protecting the encryption, i.e, 2 encryptions of the same message \n// with the same key will never result into the same encrypted message.\n// \n// Note that for decyphering, the **same** initialisation vector will be needed.\n// This vector can safely be transferred in clear with the encrypted message.\n\nexport async function encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const ivText = arrayBufferToBase64String(iv)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv },\n            key,\n            messageToArrayBuffer\n        )\n        return [arrayBufferToBase64String(cypheredMessageAB), ivText]\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Symmetric key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n// For decyphering, we need the key, the cyphered message and the initialization vector. See above the \n// comments for the encryptWithSymmetricKey function\nexport async function decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string> {\n    const decodedInitVector: ArrayBuffer = base64StringToArrayBuffer(initVector)\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"AES-GCM\", iv: decodedInitVector },\n                key,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Symmetric key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n// SHA-256 Hash from a text\nexport async function hash(text: string): Promise<string> {\n    const text2arrayBuf = textToArrayBuffer(text)\n    const hashedArray = await window.crypto.subtle.digest(\"SHA-256\", text2arrayBuf)\n    return arrayBufferToBase64String(hashedArray)\n}\n\nclass KeyStringCorrupted extends Error { }\n\n// ArrayBuffer to a Base64 string\nfunction arrayBufferToBase64String(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var byteString = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        byteString += String.fromCharCode(byteArray[i])\n    }\n    return btoa(byteString)\n}\n\n// Base64 string to an arrayBuffer\nfunction base64StringToArrayBuffer(b64str: string): ArrayBuffer {\n    try {\n        var byteStr = atob(b64str)\n        var bytes = new Uint8Array(byteStr.length)\n        for (var i = 0; i < byteStr.length; i++) {\n            bytes[i] = byteStr.charCodeAt(i)\n        }\n        return bytes.buffer\n    } catch (e) {\n        console.log(`String starting by '${b64str.substring(0, 10)}' cannot be converted to a valid key or message`)\n        throw new KeyStringCorrupted\n    }\n}\n\n// String to array buffer\nfunction textToArrayBuffer(str: string): ArrayBuffer {\n    var buf = encodeURIComponent(str) // 2 bytes for each char\n    var bufView = new Uint8Array(buf.length)\n    for (var i = 0; i < buf.length; i++) {\n        bufView[i] = buf.charCodeAt(i)\n    }\n    return bufView\n}\n\n// Array buffers to string\nfunction arrayBufferToText(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var str = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return decodeURIComponent(str)\n}\n\n", "// All message types between the application and the server\n// Message for user name\nexport class CasUserName {\n    constructor(public username: string) { }\n}\n\n\n// Message for requiring history\nexport class HistoryRequest {\n    constructor(public agentName: string, public index: number) { }\n}\n\n// Result of history request\nexport class HistoryAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public index: number,\n        public allMessages: ExtMessage[]) { }\n}\n\n// Filtering of messages\nexport class FilterRequest {\n    constructor(public from: string, public to: string, public indexmin: string) { }\n}\n\nexport class FilteredMessage {\n    constructor(public message: ExtMessage,\n        public index: number,\n        public deleted: boolean,\n        public deleter: string) { }\n}\n\n// Result of filtering request\nexport class FilteringAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public allMessages: FilteredMessage[]) { }\n}\n\n// Sending a message Result format\nexport class SendResult {\n    constructor(public success: boolean, public errorMessage: string) { }\n}\n\n// Sending messages\n// The message format\nexport class ExtMessage {\n    constructor(public sender: string, public receiver: string, public content: string) { }\n}\n\nexport class DeletingRequest {\n    constructor(\n        public indexToDelete: string) { }\n}\n\nexport class DeletingAnswer {\n    constructor(public success: boolean,\n        message: string) { }\n}\n\n// Requesting keys\nexport class KeyRequest {\n    constructor(public ownerOfTheKey: string, public publicKey: boolean, public encryption: boolean) { }\n}\n\nexport class KeyResult {\n    constructor(public success: boolean, public key: string, public errorMessage: string) { }\n}", "/* tsc --inlineSourceMap true -outFile JS/intruder.js src/libCrypto.ts src/intruder.ts --target es2015 */\n\nimport {\n    generateNonce,\n    stringToPrivateKeyForEncryption, stringToPublicKeyForEncryption,\n    publicKeyToString, privateKeyToString, stringToPrivateKeyForSignature,\n    stringToPublicKeyForSignature,\n} from './libCrypto'\n\nimport {\n    DeletingRequest, DeletingAnswer, FilterRequest, FilteringAnswer, KeyRequest,\n    KeyResult, CasUserName, ExtMessage, SendResult\n} from './serverMessages'\n\nconst filterButton = document.getElementById(\"filter-button\") as HTMLButtonElement\nconst sendButton = document.getElementById(\"send-button\") as HTMLButtonElement\nconst deleteButton = document.getElementById(\"delete-button\") as HTMLButtonElement\nconst getPublicKeyButton = document.getElementById(\"get-public-key-button\") as HTMLButtonElement\nconst getPrivateKeyButton = document.getElementById(\"get-private-key-button\") as HTMLButtonElement\n\nconst generateNonceButton = document.getElementById(\"generate-nonce-button\") as HTMLButtonElement\n\nconst public_key_owner = document.getElementById(\"public-key-owner\") as HTMLInputElement\nconst private_key_owner = document.getElementById(\"private-key-owner\") as HTMLInputElement\n\nconst publicKeyElementEnc = document.getElementById(\"public-key-enc\") as HTMLLabelElement\nconst privateKeyElementEnc = document.getElementById(\"private-key-enc\") as HTMLLabelElement\nconst publicKeyElementSign = document.getElementById(\"public-key-sign\") as HTMLLabelElement\nconst privateKeyElementSign = document.getElementById(\"private-key-sign\") as HTMLLabelElement\n\nconst nonceTextElement = document.getElementById(\"nonce\") as HTMLLabelElement\n\nconst from = document.getElementById(\"from\") as HTMLInputElement\nconst to = document.getElementById(\"to\") as HTMLInputElement\nconst indexminElt = document.getElementById(\"indexmin\") as HTMLInputElement\nconst filtered_messages = document.getElementById(\"filtered-messages\") as HTMLLabelElement\n\nconst sendfrom = document.getElementById(\"sendfrom\") as HTMLInputElement\nconst sendto = document.getElementById(\"sendto\") as HTMLInputElement\nconst sendcontent = document.getElementById(\"sendcontent\") as HTMLInputElement\nconst deleteIndex = document.getElementById(\"deleteindex\") as HTMLInputElement\n\nasync function fetchCasName(): Promise<string> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const namerequest = await fetch(\"/getuser?\" + urlParams, {\n        method: \"GET\",\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!namerequest.ok) {\n        throw new Error(`Error! status: ${namerequest.status}`);\n    }\n    const nameResult = (await namerequest.json()) as CasUserName;\n    return nameResult.username\n}\n\n// We set the default CAS name for the public key fields\nasync function setCasName() {\n    public_key_owner.value = await fetchCasName()\n    private_key_owner.value = await fetchCasName()\n}\nsetCasName()\n\n/* Name of the owner/developper of the application, i.e, the name of the folder \n   where the web page of the application is stored. E.g, for teachers' application\n   this name is \"ens\" */\n\nfunction getOwnerName(): string {\n    const path = window.location.pathname\n    const name = path.split(\"/\", 2)[1]\n    return name\n}\n\nlet ownerName = getOwnerName()\n\nfunction clearingMessages() {\n    filtered_messages.textContent = \"\"\n}\n\nfunction stringToHTML(str: string): HTMLDivElement {\n    var div_elt = document.createElement('div')\n    div_elt.innerHTML = str\n    return div_elt\n}\n\nfunction addingFilteredMessage(message: string) {\n    filtered_messages.append(stringToHTML('<p></p><p></p>' + message))\n}\n\ngenerateNonceButton.onclick = function () {\n    const nonce = generateNonce()\n    nonceTextElement.textContent = nonce\n}\n\nasync function fetchKey(user: string, publicKey: boolean, encryption: boolean): Promise<CryptoKey> {\n    // Getting the public/private key of user.\n    // For public key the boolean 'publicKey' is true.\n    // For private key the boolean 'publicKey' is false.\n    // If the key is used for encryption/decryption then the boolean 'encryption' is true.\n    // If the key is used for signature/signature verification then the boolean is false.\n    const keyRequestMessage =\n        new KeyRequest(user, publicKey, encryption)\n    // For CAS authentication we need to add the authentication ticket\n    // It is contained in urlParams\n    const urlParams = new URLSearchParams(window.location.search);\n    // For getting a key we do not need the ownerName param\n    // Because keys are independant of the applications\n    const keyrequest = await fetch(\"/getKey?\" + urlParams, {\n        method: \"POST\",\n        body: JSON.stringify(keyRequestMessage),\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!keyrequest.ok) {\n        throw new Error(`Error! status: ${keyrequest.status}`);\n    }\n    const keyResult = (await keyrequest.json()) as KeyResult;\n    if (!keyResult.success) alert(keyResult.errorMessage)\n    else {\n        if (publicKey && encryption) return await stringToPublicKeyForEncryption(keyResult.key)\n        else if (!publicKey && encryption) return await stringToPrivateKeyForEncryption(keyResult.key)\n        else if (publicKey && !encryption) return await stringToPublicKeyForSignature(keyResult.key)\n        else if (!publicKey && !encryption) return await stringToPrivateKeyForSignature(keyResult.key)\n    }\n}\n\ngetPublicKeyButton.onclick = async function () {\n    const public_key_owner_name = public_key_owner.value\n    const publicKeyEnc = await fetchKey(public_key_owner_name, true, true)\n    const publicKeySign = await fetchKey(public_key_owner_name, true, false)\n    publicKeyElementEnc.textContent = await publicKeyToString(publicKeyEnc)\n    publicKeyElementSign.textContent = await publicKeyToString(publicKeySign)\n}\n\ngetPrivateKeyButton.onclick = async function () {\n    const private_key_owner_name = private_key_owner.value\n    const privateKeyEnc = await fetchKey(private_key_owner_name, false, true)\n    const privateKeySign = await fetchKey(private_key_owner_name, false, false)\n    privateKeyElementEnc.textContent = await privateKeyToString(privateKeyEnc)\n    privateKeyElementSign.textContent = await privateKeyToString(privateKeySign)\n}\n\ndeleteButton.onclick = async function () {\n    let indexToDelete = deleteIndex.value\n    try {\n        let deleteRequest =\n            new DeletingRequest(indexToDelete)\n        const request = await fetch(\"/deleting/\" + ownerName + \"\", {\n            method: \"POST\",\n            body: JSON.stringify(deleteRequest),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as DeletingAnswer\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            alert(error.message)\n            //console.log('error message: ', error.message);\n            return new DeletingAnswer(false, error.message)\n        } else {\n            console.log('unexpected error: ', error);\n            return new DeletingAnswer(false, 'An unexpected error occurred')\n        }\n    }\n\n}\n\nasync function sendMessage(agentName: string, receiverName: string, messageContent: string): Promise<SendResult> {\n    try {\n        let messageToSend = new ExtMessage(agentName, receiverName, messageContent)\n        const request = await fetch(\"/intruderSendingMessage/\" + ownerName, {\n            method: \"POST\",\n            body: JSON.stringify(messageToSend),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as SendResult\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log(error.message)\n            return new SendResult(false, error.message)\n        } else {\n            console.log(error)\n            return new SendResult(false, 'An unexpected error occurred')\n        }\n    }\n}\n\n// the intruder sends a message in place of any user\nsendButton.onclick = async function () {\n    let agentName = sendfrom.value\n    let receiverName = sendto.value\n    let content = sendcontent.value\n    try {\n        const sendResult = await sendMessage(agentName, receiverName, content)\n        if (!sendResult.success) alert(sendResult.errorMessage)\n        else {\n            console.log(\"Successfully sent the message!\")\n        }\n    } catch (e) {\n        if (e instanceof Error) {\n            console.log(e.message)\n        } else {\n            console.log(e)\n        }\n    }\n}\n\nfilterButton.onclick = async function () {\n    try {\n        const fromText = from.value\n        const toText = to.value\n        const indexmin = indexminElt.value\n        const filterRequest =\n            new FilterRequest(fromText, toText, indexmin)\n        const request = await fetch(\"/filtering/\" + ownerName, {\n            method: \"POST\",\n            body: JSON.stringify(filterRequest),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        const result = (await request.json()) as FilteringAnswer\n        if (!result.success) { alert(result.failureMessage) }\n        else {\n            clearingMessages()\n            for (var filt_message of result.allMessages) {\n                if (filt_message.deleted) {\n                    addingFilteredMessage(`Index: ${filt_message.index} Deleted by: ${filt_message.deleter} <strike> From: ${filt_message.message.sender} To: ${filt_message.message.receiver} Content: ${filt_message.message.content} </strike>`)\n                } else {\n                    addingFilteredMessage(`Index: ${filt_message.index} From: ${filt_message.message.sender} To: ${filt_message.message.receiver} Content: ${filt_message.message.content}`)\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return error.message;\n        } else {\n            console.log('unexpected error: ', error);\n            return 'An unexpected error occurred';\n        }\n    }\n}\n\n"],
  "mappings": "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",
>>>>>>> fa95181 (ajout des tsconfig etc)
  "names": ["from", "to"]
}
