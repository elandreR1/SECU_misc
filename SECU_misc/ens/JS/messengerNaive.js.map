{
  "version": 3,
  "sources": ["../src/libCrypto.ts", "../src/serverMessages.ts", "../src/messengerNaive.ts"],
<<<<<<< HEAD
  "sourcesContent": ["/* Source: https://gist.github.com/groundrace/b5141062b47dd96a5c21c93839d4b954 */\n\n/* Available functions:\n\n    # Key/nonce generation:\n    generateAssymetricKeysForEncryption(): Promise<CryptoKey[]>\n    generateAssymetricKeysForSignature(): Promise<CryptoKey[]>\n    generateSymetricKey(): Promise<CryptoKey>\n    generateNonce(): string\n\n    # Assymetric key Encryption/Decryption/Signature/Signature verification\n    encryptWithPublicKey(pkey: CryptoKey, message: string): Promise<string>\n    decryptWithPrivateKey(skey: CryptoKey, message: string): Promise<string>\n    signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string>\n    verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean>\n\n    # Symmetric key Encryption/Decryption\n    encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]>\n    decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string>\n\n    # Importing keys from string\n    stringToPublicKeyForEncryption(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForEncryption(skeyInBase64: string): Promise<CryptoKey>\n    stringToPublicKeyForSignature(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForSignature(skeyInBase64: string): Promise<CryptoKey>\n    stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey>\n\n    # Exporting keys to string\n    publicKeyToString(key: CryptoKey): Promise<string>\n    privateKeyToString(key: CryptoKey): Promise<string>\n    symmetricKeyToString(key: CryptoKey): Promise<string>\n\n    # Hashing\n    hash(text: string): Promise<string>\n*/\n\n// import { subtle } from 'crypto'\n// LibCrypto---------------------------------------------------------------------------\n\n/*\nImports the given public key (for encryption) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForEncryption(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"encrypt\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given public key (for signature verification) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForSignature(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"verify\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for decryption)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForEncryption(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for signature)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForSignature(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\n\nexport async function publicKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"spki\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function privateKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Generates a pair of public and private RSA keys for encryption/decryption */\nexport async function generateAssymetricKeysForEncryption(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-OAEP\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a pair of public and private RSA keys for signing/verifying */\nexport async function generateAssymetricKeysForSignature(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"sign\", \"verify\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a random nonce */\nexport function generateNonce(): string {\n    const nonceArray = new Uint32Array(1)\n    self.crypto.getRandomValues(nonceArray)\n    return nonceArray[0].toString()\n}\n\n/* Encrypts a message with a public key */\nexport async function encryptWithPublicKey(publicKey: CryptoKey, message: string): Promise<string> {\n    console.log(\"Encrypt with \" + publicKey + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"RSA-OAEP\" },\n            publicKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(cypheredMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Public key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/* Sign a message with a private key */\nexport async function signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    console.log(\"Sign with \" + privateKey + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const signedMessageAB: ArrayBuffer = await window.crypto.subtle.sign(\n            \"RSASSA-PKCS1-v1_5\",\n            privateKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(signedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Signature failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Private key or message to sign is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Decrypts a message with a private key */\nexport async function decryptWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"RSA-OAEP\" },\n                privateKey,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Private key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Verification of a signature on a message with a public key */\nexport async function verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean> {\n    try {\n        const signedToArrayBuffer = base64StringToArrayBuffer(signedMessage)\n        const messageInClearToArrayBuffer = textToArrayBuffer(messageInClear)\n        const verified: boolean = await\n            window.crypto.subtle.verify(\n                \"RSASSA-PKCS1-v1_5\",\n                publicKey,\n                signedToArrayBuffer,\n                messageInClearToArrayBuffer)\n        return verified\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for signature verification\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Public key or signed message to verify is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Generates a symmetric AES-GCM key */\nexport async function generateSymetricKey(): Promise<CryptoKey> {\n    const key: CryptoKey = await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return key\n}\n\n/* a symmetric AES key into a string */\nexport async function symmetricKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"raw\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Imports the given key (in string) as a valid AES key */\nexport async function stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"raw\",\n            keyArrayBuffer,\n            \"AES-GCM\",\n            true,\n            [\"encrypt\", \"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n// When cyphering a message with a key in AES, we obtain a cyphered message and an \"initialisation vector\".\n// In this implementation, the output is a two elements array t such that t[0] is the cyphered message\n// and t[1] is the initialisation vector. To simplify, the initialisation vector is represented by a string.\n// The initialisation vectore is used for protecting the encryption, i.e, 2 encryptions of the same message \n// with the same key will never result into the same encrypted message.\n// \n// Note that for decyphering, the **same** initialisation vector will be needed.\n// This vector can safely be transferred in clear with the encrypted message.\n\nexport async function encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]> {\n    console.log(\"Encrypt with \" + key + \" message= \" + message)\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const ivText = arrayBufferToBase64String(iv)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv },\n            key,\n            messageToArrayBuffer\n        )\n        return [arrayBufferToBase64String(cypheredMessageAB), ivText]\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Symmetric key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n// For decyphering, we need the key, the cyphered message and the initialization vector. See above the \n// comments for the encryptWithSymmetricKey function\nexport async function decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string> {\n    const decodedInitVector: ArrayBuffer = base64StringToArrayBuffer(initVector)\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"AES-GCM\", iv: decodedInitVector },\n                key,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Symmetric key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n// SHA-256 Hash from a text\nexport async function hash(text: string): Promise<string> {\n    const text2arrayBuf = textToArrayBuffer(text)\n    const hashedArray = await window.crypto.subtle.digest(\"SHA-256\", text2arrayBuf)\n    return arrayBufferToBase64String(hashedArray)\n}\n\nclass KeyStringCorrupted extends Error { }\n\n// ArrayBuffer to a Base64 string\nfunction arrayBufferToBase64String(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var byteString = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        byteString += String.fromCharCode(byteArray[i])\n    }\n    return btoa(byteString)\n}\n\n// Base64 string to an arrayBuffer\nfunction base64StringToArrayBuffer(b64str: string): ArrayBuffer {\n    try {\n        var byteStr = atob(b64str)\n        var bytes = new Uint8Array(byteStr.length)\n        for (var i = 0; i < byteStr.length; i++) {\n            bytes[i] = byteStr.charCodeAt(i)\n        }\n        return bytes.buffer\n    } catch (e) {\n        console.log(`String starting by '${b64str.substring(0, 10)}' cannot be converted to a valid key or message`)\n        throw new KeyStringCorrupted\n    }\n}\n\n// String to array buffer\nfunction textToArrayBuffer(str: string): ArrayBuffer {\n    var buf = encodeURIComponent(str) // 2 bytes for each char\n    var bufView = new Uint8Array(buf.length)\n    for (var i = 0; i < buf.length; i++) {\n        bufView[i] = buf.charCodeAt(i)\n    }\n    return bufView\n}\n\n// Array buffers to string\nfunction arrayBufferToText(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var str = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return decodeURIComponent(str)\n}\n\n", "// All message types between the application and the server\n// Message for user name\nexport class CasUserName {\n    constructor(public username: string) { }\n}\n\n\n// Message for requiring history\nexport class HistoryRequest {\n    constructor(public agentName: string, public index: number) { }\n}\n\n// Result of history request\nexport class HistoryAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public index: number,\n        public allMessages: ExtMessage[]) { }\n}\n\n// Filtering of messages\nexport class FilterRequest {\n    constructor(public from: string, public to: string, public indexmin: string) { }\n}\n\nexport class FilteredMessage {\n    constructor(public message: ExtMessage,\n        public index: number,\n        public deleted: boolean,\n        public deleter: string) { }\n}\n\n// Result of filtering request\nexport class FilteringAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public allMessages: FilteredMessage[]) { }\n}\n\n// Sending a message Result format\nexport class SendResult {\n    constructor(public success: boolean, public errorMessage: string) { }\n}\n\n// Sending messages\n// The message format\nexport class ExtMessage {\n    constructor(public sender: string, public receiver: string, public content: string) { }\n}\n\nexport class DeletingRequest {\n    constructor(\n        public indexToDelete: string) { }\n}\n\nexport class DeletingAnswer {\n    constructor(public success: boolean,\n        message: string) { }\n}\n\n// Requesting keys\nexport class KeyRequest {\n    constructor(public ownerOfTheKey: string, public publicKey: boolean, public encryption: boolean) { }\n}\n\nexport class KeyResult {\n    constructor(public success: boolean, public key: string, public errorMessage: string) { }\n}", "\nimport {\n    encryptWithPublicKey, decryptWithPrivateKey, stringToPrivateKeyForEncryption, stringToPublicKeyForEncryption,\n    stringToPrivateKeyForSignature,\n    stringToPublicKeyForSignature, privateKeyToString\n} from './libCrypto'\n\nimport {\n    HistoryAnswer, HistoryRequest, KeyRequest, KeyResult, CasUserName, ExtMessage, SendResult,\n} from './serverMessages'\n\nfunction f() { privateKeyToString }\n\n// To detect if we can use window.crypto.subtle\nif (!window.isSecureContext) alert(\"Not secure context!\")\n\n//Index of the last read message\nlet lastIndexInHistory = 0\n// Switching to another user (apart from the cas-user-name)\nconst userButtonLabel = document.getElementById(\"user-name\") as HTMLLabelElement\n\nconst sendButton = document.getElementById(\"send-button\") as HTMLButtonElement\nconst receiver = document.getElementById(\"receiver\") as HTMLInputElement\nconst message = document.getElementById(\"message\") as HTMLInputElement\nconst received_messages = document.getElementById(\"exchanged-messages\") as HTMLLabelElement\n\nfunction clearingMessages() {\n    received_messages.textContent = \"\"\n}\n\nfunction stringToHTML(str: string): HTMLDivElement {\n    var div_elt = document.createElement('div')\n    div_elt.innerHTML = str\n    return div_elt\n}\n\nfunction addingReceivedMessage(message: string) {\n    received_messages.append(stringToHTML('<p></p><p></p>' + message))\n}\n\n/* Name of the user of the application... can be Alice/Bob for attacking purposes */\nlet globalUserName = \"\"\n\nasync function fetchCasName(): Promise<string> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const namerequest = await fetch(\"/getuser?\" + urlParams, {\n        method: \"GET\",\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!namerequest.ok) {\n        throw new Error(`Error! status: ${namerequest.status}`);\n    }\n    const nameResult = (await namerequest.json()) as CasUserName;\n    return nameResult.username\n}\n\nasync function setCasName() {\n    globalUserName = await fetchCasName()\n    // We replace the name of the user of the application as the default name\n    // In the window\n    userButtonLabel.textContent = globalUserName\n}\n\nsetCasName()\n\n/* Name of the owner/developper of the application, i.e, the name of the folder \n   where the web page of the application is stored. E.g, for teachers' application\n   this name is \"ens\" */\n\nfunction getOwnerName(): string {\n    const path = window.location.pathname\n    const name = path.split(\"/\", 2)[1]\n    return name\n}\n\nlet ownerName = getOwnerName()\n\n\nasync function fetchKey(user: string, publicKey: boolean, encryption: boolean): Promise<CryptoKey> {\n    // Getting the public/private key of user.\n    // For public key the boolean 'publicKey' is true.\n    // For private key the boolean 'publicKey' is false.\n    // If the key is used for encryption/decryption then the boolean 'encryption' is true.\n    // If the key is used for signature/signature verification then the boolean is false.\n    const keyRequestMessage =\n        new KeyRequest(user, publicKey, encryption)\n    // For CAS authentication we need to add the authentication ticket\n    // It is contained in urlParams\n    const urlParams = new URLSearchParams(window.location.search);\n    // For getting a key we do not need the ownerName param\n    // Because keys are independant of the applications\n    const keyrequest = await fetch(\"/getKey?\" + urlParams, {\n        method: \"POST\",\n        body: JSON.stringify(keyRequestMessage),\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!keyrequest.ok) {\n        throw new Error(`Error! status: ${keyrequest.status}`);\n    }\n    const keyResult = (await keyrequest.json()) as KeyResult;\n    if (!keyResult.success) alert(keyResult.errorMessage)\n    else {\n        if (publicKey && encryption) return await stringToPublicKeyForEncryption(keyResult.key)\n        else if (!publicKey && encryption) return await stringToPrivateKeyForEncryption(keyResult.key)\n        else if (publicKey && !encryption) return await stringToPublicKeyForSignature(keyResult.key)\n        else if (!publicKey && !encryption) return await stringToPrivateKeyForSignature(keyResult.key)\n    }\n}\n\nasync function sendMessage(agentName: string, receiverName: string, messageContent: string): Promise<SendResult> {\n    try {\n        let messageToSend =\n            new ExtMessage(agentName, receiverName, messageContent)\n        const urlParams = new URLSearchParams(window.location.search);\n\n        const request = await fetch(\"/sendingMessage/\" + ownerName + \"?\" + urlParams, {\n            method: \"POST\",\n            body: JSON.stringify(messageToSend),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as SendResult\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return new SendResult(false, error.message)\n        } else {\n            console.log('unexpected error: ', error);\n            return new SendResult(false, 'An unexpected error occurred')\n        }\n    }\n}\n\n// Detect when the Enter key is pressed in the message field.\n// If so, we click on the \"send\" button.\nmessage.addEventListener(\"keyup\", function (event) {\n    if (event.key === \"Enter\") {\n        sendButton.click()\n    }\n});\n\nsendButton.onclick = async function () {\n    let agentName = globalUserName\n    let receiverName = receiver.value\n    let contentToEncrypt = JSON.stringify([agentName, message.value])\n    // we fetch the public key of B\n    try {\n        const kb = await fetchKey(receiverName, true, true)\n        // We encrypt\n        const encryptedMessage = await encryptWithPublicKey(kb, contentToEncrypt)\n        // And send\n        const sendResult = await sendMessage(agentName, receiverName, encryptedMessage)\n        if (!sendResult.success) console.log(sendResult.errorMessage)\n        else {\n            console.log(\"Successfully sent the message!\")\n            // We add the message to the list of sent messages\n            const textToAdd = `<font color=\"blue\"> ${agentName} -> ${receiverName} : (${readableTime()}) ${message.value} </font>`\n            addingReceivedMessage(textToAdd)\n        }\n    } catch (e) {\n        if (e instanceof Error) {\n            console.log('error message: ', e.message)\n        } else {\n            console.log('unexpected error: ', e);\n        }\n    }\n}\n\n// Returning a string representing the current time in the format\n// HH:MM:SS\nfunction readableTime(): string {\n    const now = new Date()\n    const hours = now.getHours().toString()\n    const minutes = now.getMinutes().toString()\n    const seconds = now.getSeconds().toString()\n    // Since getHours() etc return a decimal count for hours, etc. we explicitely add 0 when there\n    // are no tens digit.\n    return `${(hours.length === 1) ? \"0\" + hours : hours}:${(minutes.length === 1) ? \"0\" + minutes : minutes}:${(seconds.length === 1) ? \"0\" + seconds : seconds}`\n}\n\n// Parsing/Recognizing a message sent to app_user\n// The first element of the tuple is a boolean saying if the message was for the user\n// If this boolean is true, then the second element is the name of the sender\n// and the third is the content of the message\nasync function analyseMessage(message: ExtMessage): Promise<[boolean, string, string]> {\n    const user = globalUserName\n    try {\n        const messageSender = message.sender\n        const messageContent = message.content\n        if (message.receiver !== user) {\n            // If the message is not sent to the user, we do not consider it\n            return [false, \"\", \"\"]\n        }\n        else {\n            //we fetch user private key to decrypt the message\n            try {\n                const privkey = await fetchKey(user, false, true)\n                const messageInClearString = await decryptWithPrivateKey(privkey, messageContent)\n                const messageArrayInClear = JSON.parse(messageInClearString) as string[]\n                const messageSenderInMessage = messageArrayInClear[0]\n                const messageInClear = messageArrayInClear[1]\n                if (messageSenderInMessage == messageSender) {\n                    return [true, messageSender, eval(\"`(${readableTime()}) \" + messageInClear + \"`\")]\n                }\n                else {\n                    console.log(\"Real message sender and message sender name in the message do not coincide\")\n                }\n            } catch (e) {\n                console.log(\"analyseMessage: decryption failed because of \" + e)\n                return [false, \"\", \"\"]\n            }\n        }\n    } catch (e) {\n        console.log(\"analyseMessage: decryption failed because of \" + e)\n        return [false, \"\", \"\"]\n    }\n}\n\n// action for receiving message \n// 1. A -> B: {A,message}Kb     \nfunction actionOnMessageOne(fromA: string, messageContent: string) {\n    const user = globalUserName\n    const textToAdd = `${fromA} -> ${user} : ${messageContent} `\n    addingReceivedMessage(textToAdd)\n}\n\n// function for refreshing the content of the window (automatic or manual see below)\nasync function refresh() {\n    try {\n        const user = globalUserName\n        const historyRequest =\n            new HistoryRequest(user, lastIndexInHistory)\n        const urlParams = new URLSearchParams(window.location.search);\n        const request = await fetch(\"/history/\" + ownerName + \"?\" + urlParams\n            , {\n                method: \"POST\",\n                body: JSON.stringify(historyRequest),\n                headers: {\n                    \"Content-type\": \"application/json; charset=UTF-8\"\n                }\n            });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status} `);\n        }\n        const result = (await request.json()) as HistoryAnswer\n        if (!result.success) { alert(result.failureMessage) }\n        else {\n            // We update the index with the index of last read message from message server\n            lastIndexInHistory = result.index\n            if (result.allMessages.length != 0) {\n                for (var m of result.allMessages) {\n                    let [b, sender, msgContent] = await analyseMessage(m)\n                    if (b) actionOnMessageOne(sender, msgContent)\n                    else console.log(\"Msg \" + m + \" cannot be exploited by \" + user)\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return error.message;\n        } else {\n            console.log('unexpected error: ', error);\n            return 'An unexpected error occurred';\n        }\n    }\n}\n\n// Automatic refresh\nconst intervalRefresh = setInterval(refresh, 2000)\n\n\n"],
  "mappings": "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",
=======
  "sourcesContent": ["/* Source: https://gist.github.com/groundrace/b5141062b47dd96a5c21c93839d4b954 */\n\n/* Available functions:\n\n    # Key/nonce generation:\n    generateAssymetricKeysForEncryption(): Promise<CryptoKey[]>\n    generateAssymetricKeysForSignature(): Promise<CryptoKey[]>\n    generateSymetricKey(): Promise<CryptoKey>\n    generateNonce(): string\n\n    # Assymetric key Encryption/Decryption/Signature/Signature verification\n    encryptWithPublicKey(pkey: CryptoKey, message: string): Promise<string>\n    decryptWithPrivateKey(skey: CryptoKey, message: string): Promise<string>\n    signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string>\n    verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean>\n\n    # Symmetric key Encryption/Decryption\n    encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]>\n    decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string>\n\n    # Importing keys from string\n    stringToPublicKeyForEncryption(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForEncryption(skeyInBase64: string): Promise<CryptoKey>\n    stringToPublicKeyForSignature(pkeyInBase64: string): Promise<CryptoKey>\n    stringToPrivateKeyForSignature(skeyInBase64: string): Promise<CryptoKey>\n    stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey>\n\n    # Exporting keys to string\n    publicKeyToString(key: CryptoKey): Promise<string>\n    privateKeyToString(key: CryptoKey): Promise<string>\n    symmetricKeyToString(key: CryptoKey): Promise<string>\n\n    # Hashing\n    hash(text: string): Promise<string>\n*/\n\n// import { subtle } from 'crypto'\n// LibCrypto---------------------------------------------------------------------------\n\n/*\nImports the given public key (for encryption) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForEncryption(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"encrypt\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for encryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given public key (for signature verification) from the import space.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function stringToPublicKeyForSignature(pkeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(pkeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"spki\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"verify\"]\n        )\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the public key (for signature verification) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for decryption)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForEncryption(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSA-OAEP\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for decryption) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n/*\nImports the given private key (in string) as a valid private key (for signature)\nThe SubtleCrypto imposes to use the \"pkcs8\" ?? format for importing public keys.\n*/\nexport async function stringToPrivateKeyForSignature(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"pkcs8\",\n            keyArrayBuffer,\n            {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: \"SHA-256\",\n            },\n            true,\n            [\"sign\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the private key (for signature) is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\n\nexport async function publicKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"spki\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/*\nExports the given public key into a valid string.\nThe SubtleCrypto imposes to use the \"spki\" format for exporting public keys.\n*/\nexport async function privateKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"pkcs8\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Generates a pair of public and private RSA keys for encryption/decryption */\nexport async function generateAssymetricKeysForEncryption(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-OAEP\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a pair of public and private RSA keys for signing/verifying */\nexport async function generateAssymetricKeysForSignature(): Promise<CryptoKey[]> {\n    const keypair: CryptoKeyPair = await window.crypto.subtle.generateKey(\n        {\n            name: \"RSASSA-PKCS1-v1_5\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([1, 0, 1]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"sign\", \"verify\"]\n    )\n    return [keypair.publicKey, keypair.privateKey]\n}\n\n/* Generates a random nonce */\nexport function generateNonce(): string {\n    const nonceArray = new Uint32Array(1)\n    self.crypto.getRandomValues(nonceArray)\n    return nonceArray[0].toString()\n}\n\n/* Encrypts a message with a public key */\nexport async function encryptWithPublicKey(publicKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"RSA-OAEP\" },\n            publicKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(cypheredMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Public key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Sign a message with a private key */\nexport async function signWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const signedMessageAB: ArrayBuffer = await window.crypto.subtle.sign(\n            \"RSASSA-PKCS1-v1_5\",\n            privateKey,\n            messageToArrayBuffer\n        )\n        return arrayBufferToBase64String(signedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Signature failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Private key or message to sign is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n/* Decrypts a message with a private key */\nexport async function decryptWithPrivateKey(privateKey: CryptoKey, message: string): Promise<string> {\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"RSA-OAEP\" },\n                privateKey,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Private key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Verification of a signature on a message with a public key */\nexport async function verifySignatureWithPublicKey(publicKey: CryptoKey, messageInClear: string, signedMessage: string): Promise<boolean> {\n    try {\n        const signedToArrayBuffer = base64StringToArrayBuffer(signedMessage)\n        const messageInClearToArrayBuffer = textToArrayBuffer(messageInClear)\n        const verified: boolean = await\n            window.crypto.subtle.verify(\n                \"RSASSA-PKCS1-v1_5\",\n                publicKey,\n                signedToArrayBuffer,\n                messageInClearToArrayBuffer)\n        return verified\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for signature verification\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Public key or signed message to verify is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n\n/* Generates a symmetric AES-GCM key */\nexport async function generateSymetricKey(): Promise<CryptoKey> {\n    const key: CryptoKey = await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    )\n    return key\n}\n\n/* a symmetric AES key into a string */\nexport async function symmetricKeyToString(key: CryptoKey): Promise<string> {\n    const exportedKey: ArrayBuffer = await window.crypto.subtle.exportKey(\"raw\", key)\n    return arrayBufferToBase64String(exportedKey)\n}\n\n/* Imports the given key (in string) as a valid AES key */\nexport async function stringToSymmetricKey(skeyBase64: string): Promise<CryptoKey> {\n    try {\n        const keyArrayBuffer: ArrayBuffer = base64StringToArrayBuffer(skeyBase64)\n        const key: CryptoKey = await window.crypto.subtle.importKey(\n            \"raw\",\n            keyArrayBuffer,\n            \"AES-GCM\",\n            true,\n            [\"encrypt\", \"decrypt\"])\n        return key\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"String for the symmetric key is ill-formed!\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n\n// When cyphering a message with a key in AES, we obtain a cyphered message and an \"initialisation vector\".\n// In this implementation, the output is a two elements array t such that t[0] is the cyphered message\n// and t[1] is the initialisation vector. To simplify, the initialisation vector is represented by a string.\n// The initialisation vectore is used for protecting the encryption, i.e, 2 encryptions of the same message \n// with the same key will never result into the same encrypted message.\n// \n// Note that for decyphering, the **same** initialisation vector will be needed.\n// This vector can safely be transferred in clear with the encrypted message.\n\nexport async function encryptWithSymmetricKey(key: CryptoKey, message: string): Promise<string[]> {\n    try {\n        const messageToArrayBuffer = textToArrayBuffer(message)\n        const iv = window.crypto.getRandomValues(new Uint8Array(12));\n        const ivText = arrayBufferToBase64String(iv)\n        const cypheredMessageAB: ArrayBuffer = await window.crypto.subtle.encrypt(\n            { name: \"AES-GCM\", iv },\n            key,\n            messageToArrayBuffer\n        )\n        return [arrayBufferToBase64String(cypheredMessageAB), ivText]\n    } catch (e) {\n        if (e instanceof DOMException) { console.log(e); console.log(\"Encryption failed!\") }\n        else if (e instanceof KeyStringCorrupted) { console.log(\"Symmetric key or message to encrypt is ill-formed\") }\n        else { console.log(e) }\n        throw e\n    }\n}\n\n// For decyphering, we need the key, the cyphered message and the initialization vector. See above the \n// comments for the encryptWithSymmetricKey function\nexport async function decryptWithSymmetricKey(key: CryptoKey, message: string, initVector: string): Promise<string> {\n    const decodedInitVector: ArrayBuffer = base64StringToArrayBuffer(initVector)\n    try {\n        const decrytpedMessageAB: ArrayBuffer = await\n            window.crypto.subtle.decrypt(\n                { name: \"AES-GCM\", iv: decodedInitVector },\n                key,\n                base64StringToArrayBuffer(message)\n            )\n        return arrayBufferToText(decrytpedMessageAB)\n    } catch (e) {\n        if (e instanceof DOMException) {\n            console.log(\"Invalid key, message or algorithm for decryption\")\n        } else if (e instanceof KeyStringCorrupted) {\n            console.log(\"Symmetric key or message to decrypt is ill-formed\")\n        }\n        else console.log(\"Decryption failed\")\n        throw e\n    }\n}\n\n// SHA-256 Hash from a text\nexport async function hash(text: string): Promise<string> {\n    const text2arrayBuf = textToArrayBuffer(text)\n    const hashedArray = await window.crypto.subtle.digest(\"SHA-256\", text2arrayBuf)\n    return arrayBufferToBase64String(hashedArray)\n}\n\nclass KeyStringCorrupted extends Error { }\n\n// ArrayBuffer to a Base64 string\nfunction arrayBufferToBase64String(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var byteString = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        byteString += String.fromCharCode(byteArray[i])\n    }\n    return btoa(byteString)\n}\n\n// Base64 string to an arrayBuffer\nfunction base64StringToArrayBuffer(b64str: string): ArrayBuffer {\n    try {\n        var byteStr = atob(b64str)\n        var bytes = new Uint8Array(byteStr.length)\n        for (var i = 0; i < byteStr.length; i++) {\n            bytes[i] = byteStr.charCodeAt(i)\n        }\n        return bytes.buffer\n    } catch (e) {\n        console.log(`String starting by '${b64str.substring(0, 10)}' cannot be converted to a valid key or message`)\n        throw new KeyStringCorrupted\n    }\n}\n\n// String to array buffer\nfunction textToArrayBuffer(str: string): ArrayBuffer {\n    var buf = encodeURIComponent(str) // 2 bytes for each char\n    var bufView = new Uint8Array(buf.length)\n    for (var i = 0; i < buf.length; i++) {\n        bufView[i] = buf.charCodeAt(i)\n    }\n    return bufView\n}\n\n// Array buffers to string\nfunction arrayBufferToText(arrayBuffer: ArrayBuffer): string {\n    var byteArray = new Uint8Array(arrayBuffer)\n    var str = ''\n    for (var i = 0; i < byteArray.byteLength; i++) {\n        str += String.fromCharCode(byteArray[i])\n    }\n    return decodeURIComponent(str)\n}\n\n", "// All message types between the application and the server\n// Message for user name\nexport class CasUserName {\n    constructor(public username: string) { }\n}\n\n\n// Message for requiring history\nexport class HistoryRequest {\n    constructor(public agentName: string, public index: number) { }\n}\n\n// Result of history request\nexport class HistoryAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public index: number,\n        public allMessages: ExtMessage[]) { }\n}\n\n// Filtering of messages\nexport class FilterRequest {\n    constructor(public from: string, public to: string, public indexmin: string) { }\n}\n\nexport class FilteredMessage {\n    constructor(public message: ExtMessage,\n        public index: number,\n        public deleted: boolean,\n        public deleter: string) { }\n}\n\n// Result of filtering request\nexport class FilteringAnswer {\n    constructor(public success: boolean,\n        public failureMessage: string,\n        public allMessages: FilteredMessage[]) { }\n}\n\n// Sending a message Result format\nexport class SendResult {\n    constructor(public success: boolean, public errorMessage: string) { }\n}\n\n// Sending messages\n// The message format\nexport class ExtMessage {\n    constructor(public sender: string, public receiver: string, public content: string) { }\n}\n\nexport class DeletingRequest {\n    constructor(\n        public indexToDelete: string) { }\n}\n\nexport class DeletingAnswer {\n    constructor(public success: boolean,\n        message: string) { }\n}\n\n// Requesting keys\nexport class KeyRequest {\n    constructor(public ownerOfTheKey: string, public publicKey: boolean, public encryption: boolean) { }\n}\n\nexport class KeyResult {\n    constructor(public success: boolean, public key: string, public errorMessage: string) { }\n}", "/* tsc --inlineSourceMap  true -outFile JS/messengerNaive.js src/libCrypto.ts src/messengerNaive.ts --target es2015 */\n\n/* \nhttp://localhost:8080/messengerNaive2.html\nUsage: ouvrir 2 onglets sur localhost:8080/messenger.html\n\nDans un des onglets choisir\n\n(a) toto@univ-rennes.fr acting for toto@univ-rennes.fr\net envoyer un message \u00E0 titi@univ-rennes.fr\n\nDans l'autre choisir:\n(b) titi@univ-rennes.fr acting for titi@univ-rennes.fr\n\nPeut suivre les messages \u00E9chang\u00E9s avec filter.html\n*/\n\n// import { stringToPublicKey, stringToPrivateKey, encryptWithPublicKey, decryptWithPrivateKey } from './libCrypto'\n\nimport {\n    encryptWithPublicKey, decryptWithPrivateKey, stringToPrivateKeyForEncryption, stringToPublicKeyForEncryption,\n    stringToPrivateKeyForSignature,\n    stringToPublicKeyForSignature, privateKeyToString\n} from './libCrypto'\n\nimport {\n    HistoryAnswer, HistoryRequest, KeyRequest, KeyResult, CasUserName, ExtMessage, SendResult,\n\n} from './serverMessages'\n\n// To detect if we can use window.crypto.subtle\nif (!window.isSecureContext) alert(\"Not secure context!\")\n\n//Index of the last read message\nlet lastIndexInHistory = 0\n\n// Switching to another user (apart from the cas-user-name)\nconst userButton = document.getElementById(\"choose-user\") as HTMLButtonElement\nconst aliceButton = document.getElementById(\"choose-alice\") as HTMLButtonElement\nconst bobButton = document.getElementById(\"choose-bob\") as HTMLButtonElement\nconst userButtonLabel = document.getElementById(\"user-name\") as HTMLLabelElement\n\nconst sendButton = document.getElementById(\"send-button\") as HTMLButtonElement\n\nconst receiver = document.getElementById(\"receiver\") as HTMLInputElement\nconst message = document.getElementById(\"message\") as HTMLInputElement\nconst received_messages = document.getElementById(\"exchanged-messages\") as HTMLLabelElement\n\nfunction clearingMessages() {\n    received_messages.textContent = \"\"\n}\n\nfunction stringToHTML(str: string): HTMLDivElement {\n    var div_elt = document.createElement('div')\n    div_elt.innerHTML = str\n    return div_elt\n}\n\nfunction addingReceivedMessage(message: string) {\n    received_messages.append(stringToHTML('<p></p><p></p>' + message))\n}\n\n/* Name of the user of the application... can be Alice/Bob for attacking purposes */\nlet globalUserName = \"\"\n\nasync function fetchCasName(): Promise<string> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const namerequest = await fetch(\"/getuser?\" + urlParams, {\n        method: \"GET\",\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!namerequest.ok) {\n        throw new Error(`Error! status: ${namerequest.status}`);\n    }\n    const nameResult = (await namerequest.json()) as CasUserName;\n    return nameResult.username\n}\n\nasync function setCasName() {\n    globalUserName = await fetchCasName()\n    // We replace the name of the user of the application as the default name\n    // In the window\n    userButtonLabel.textContent = globalUserName\n}\n\nsetCasName()\n\n/* Name of the owner/developper of the application, i.e, the name of the folder \n   where the web page of the application is stored. E.g, for teachers' application\n   this name is \"ens\" */\n\nfunction getOwnerName(): string {\n    const path = window.location.pathname\n    const name = path.split(\"/\", 2)[1]\n    return name\n}\n\nlet ownerName = getOwnerName()\n\n/* All buttons */\nuserButton.onclick = async function () {\n    globalUserName = await fetchCasName()\n    console.log(`Setting user to ${globalUserName}`)\n    clearingMessages()\n}\n\naliceButton.onclick = async function () {\n    globalUserName = \"Alice\"\n    console.log(`Setting user to ${globalUserName}`)\n    clearingMessages()\n}\n\nbobButton.onclick = async function () {\n    globalUserName = \"Bob\"\n    console.log(`Setting user to ${globalUserName}`)\n    clearingMessages()\n}\n\n\nasync function fetchKey(user: string, publicKey: boolean, encryption: boolean): Promise<CryptoKey> {\n    // Getting the public/private key of user.\n    // For public key the boolean 'publicKey' is true.\n    // For private key the boolean 'publicKey' is false.\n    // If the key is used for encryption/decryption then the boolean 'encryption' is true.\n    // If the key is used for signature/signature verification then the boolean is false.\n    const keyRequestMessage =\n        new KeyRequest(user, publicKey, encryption)\n    // For CAS authentication we need to add the authentication ticket\n    // It is contained in urlParams\n    const urlParams = new URLSearchParams(window.location.search);\n    // For getting a key we do not need the ownerName param\n    // Because keys are independant of the applications\n    const keyrequest = await fetch(\"/getKey?\" + urlParams, {\n        method: \"POST\",\n        body: JSON.stringify(keyRequestMessage),\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    });\n    if (!keyrequest.ok) {\n        throw new Error(`Error! status: ${keyrequest.status}`);\n    }\n    const keyResult = (await keyrequest.json()) as KeyResult;\n    if (!keyResult.success) alert(keyResult.errorMessage)\n    else {\n        if (publicKey && encryption) return await stringToPublicKeyForEncryption(keyResult.key)\n        else if (!publicKey && encryption) return await stringToPrivateKeyForEncryption(keyResult.key)\n        else if (publicKey && !encryption) return await stringToPublicKeyForSignature(keyResult.key)\n        else if (!publicKey && !encryption) return await stringToPrivateKeyForSignature(keyResult.key)\n    }\n}\n\n\nasync function sendMessage(agentName: string, receiverName: string, messageContent: string): Promise<SendResult> {\n    try {\n        let messageToSend =\n            new ExtMessage(agentName, receiverName, messageContent)\n        const urlParams = new URLSearchParams(window.location.search);\n\n        const request = await fetch(\"/sendingMessage/\" + ownerName + \"?\" + urlParams, {\n            method: \"POST\",\n            body: JSON.stringify(messageToSend),\n            headers: {\n                \"Content-type\": \"application/json; charset=UTF-8\"\n            }\n        });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status}`);\n        }\n        // Dealing with the answer of the message server\n        return (await request.json()) as SendResult\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return new SendResult(false, error.message)\n        } else {\n            console.log('unexpected error: ', error);\n            return new SendResult(false, 'An unexpected error occurred')\n        }\n    }\n}\n\n// Detect when the Enter key is pressed in the message field.\n// If so, we click on the \"send\" button.\nmessage.addEventListener(\"keyup\", function (event) {\n    if (event.key === \"Enter\") {\n        sendButton.click()\n    }\n});\n\nsendButton.onclick = async function () {\n    let agentName = globalUserName\n    let receiverName = receiver.value\n    let contentToEncrypt = JSON.stringify([agentName, message.value])\n    // we fetch the public key of B\n    try {\n        const kb = await fetchKey(receiverName, true, true)\n        // We encrypt\n        const encryptedMessage = await encryptWithPublicKey(kb, contentToEncrypt)\n        // And send\n        const sendResult = await sendMessage(agentName, receiverName, encryptedMessage)\n        if (!sendResult.success) console.log(sendResult.errorMessage)\n        else {\n            console.log(\"Successfully sent the message!\")\n            // We add the message to the list of sent messages\n            const textToAdd = `<font color=\"blue\"> ${agentName} -> ${receiverName} : (${readableTime()}) ${message.value} </font>`\n            addingReceivedMessage(textToAdd)\n        }\n    } catch (e) {\n        if (e instanceof Error) {\n            console.log('error message: ', e.message)\n        } else {\n            console.log('unexpected error: ', e);\n        }\n    }\n}\n\n// Returning a string representing the current time in the format\n// HH:MM:SS\nfunction readableTime(): string {\n    const now = new Date()\n    const hours = now.getHours().toString()\n    const minutes = now.getMinutes().toString()\n    const seconds = now.getSeconds().toString()\n    // Since getHours() etc return a decimal count for hours, etc. we explicitely add 0 when there\n    // are no tens digit.\n    return `${(hours.length === 1) ? \"0\" + hours : hours}:${(minutes.length === 1) ? \"0\" + minutes : minutes}:${(seconds.length === 1) ? \"0\" + seconds : seconds}`\n}\n\n// Parsing/Recognizing a message sent to app_user\n// The first element of the tuple is a boolean saying if the message was for the user\n// If this boolean is true, then the second element is the name of the sender\n// and the third is the content of the message\nasync function analyseMessage(message: ExtMessage): Promise<[boolean, string, string]> {\n    const user = globalUserName\n    try {\n        const messageSender = message.sender\n        const messageContent = message.content\n        if (message.receiver !== user) {\n            // If the message is not sent to the user, we do not consider it\n            return [false, \"\", \"\"]\n        }\n        else {\n            //we fetch user private key to decrypt the message\n            try {\n                const privkey = await fetchKey(user, false, true)\n                const messageInClearString = await decryptWithPrivateKey(privkey, messageContent)\n                const messageArrayInClear = JSON.parse(messageInClearString) as string[]\n                const messageSenderInMessage = messageArrayInClear[0]\n                const messageInClear = messageArrayInClear[1]\n                if (messageSenderInMessage == messageSender) {\n                    return [true, messageSender, eval(\"`(${readableTime()}) \" + messageInClear + \"`\")]\n                }\n                else {\n                    console.log(\"Real message sender and message sender name in the message do not coincide\")\n                }\n            } catch (e) {\n                console.log(\"analyseMessage: decryption failed because of \" + e)\n                return [false, \"\", \"\"]\n            }\n        }\n    } catch (e) {\n        console.log(\"analyseMessage: decryption failed because of \" + e)\n        return [false, \"\", \"\"]\n    }\n}\n\n// action for receiving message \n// 1. A -> B: {A,message}Kb     \nfunction actionOnMessageOne(fromA: string, messageContent: string) {\n    const user = globalUserName\n    const textToAdd = `${fromA} -> ${user} : ${messageContent} `\n    addingReceivedMessage(textToAdd)\n}\n\n// function for refreshing the content of the window (automatic or manual see below)\nasync function refresh() {\n    try {\n        const user = globalUserName\n        const historyRequest =\n            new HistoryRequest(user, lastIndexInHistory)\n        const urlParams = new URLSearchParams(window.location.search);\n        const request = await fetch(\"/history/\" + ownerName + \"?\" + urlParams\n            , {\n                method: \"POST\",\n                body: JSON.stringify(historyRequest),\n                headers: {\n                    \"Content-type\": \"application/json; charset=UTF-8\"\n                }\n            });\n        if (!request.ok) {\n            throw new Error(`Error! status: ${request.status} `);\n        }\n        const result = (await request.json()) as HistoryAnswer\n        if (!result.success) { alert(result.failureMessage) }\n        else {\n            // We update the index with the index of last read message from message server\n            lastIndexInHistory = result.index\n            if (result.allMessages.length != 0) {\n                for (var m of result.allMessages) {\n                    let [b, sender, msgContent] = await analyseMessage(m)\n                    if (b) actionOnMessageOne(sender, msgContent)\n                    else console.log(\"Msg \" + m + \" cannot be exploited by \" + user)\n                }\n            }\n        }\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('error message: ', error.message);\n            return error.message;\n        } else {\n            console.log('unexpected error: ', error);\n            return 'An unexpected error occurred';\n        }\n    }\n}\n\n// Automatic refresh\nconst intervalRefresh = setInterval(refresh, 2000)\n\n\n"],
  "mappings": "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",
>>>>>>> fa95181 (ajout des tsconfig etc)
  "names": ["message", "message", "user", "messageContent"]
}
